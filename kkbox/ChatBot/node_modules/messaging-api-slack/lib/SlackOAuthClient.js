'use strict';Object.defineProperty(exports, "__esModule", { value: true });var _extends = Object.assign || function (target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i];for (var key in source) {if (Object.prototype.hasOwnProperty.call(source, key)) {target[key] = source[key];}}}return target;};

var _querystring = require('querystring');var _querystring2 = _interopRequireDefault(_querystring);

var _axios = require('axios');var _axios2 = _interopRequireDefault(_axios);
var _axiosError = require('axios-error');var _axiosError2 = _interopRequireDefault(_axiosError);function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}function _asyncToGenerator(fn) {return function () {var gen = fn.apply(this, arguments);return new Promise(function (resolve, reject) {function step(key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {return Promise.resolve(value).then(function (value) {step("next", value);}, function (err) {step("throw", err);});}}return step("next");});};}


























































class SlackOAuthClient {
  static connect(accessTokenOrConfig) {
    return new SlackOAuthClient(accessTokenOrConfig);
  }





  constructor(accessTokenOrConfig) {
    let origin;
    if (accessTokenOrConfig && typeof accessTokenOrConfig === 'object') {
      const config = accessTokenOrConfig;

      this._token = config.accessToken;
      origin = config.origin;
    } else {
      // Bot User OAuth Access Token
      this._token = accessTokenOrConfig;
    }

    // Web API
    // https://api.slack.com/web
    this._axios = _axios2.default.create({
      baseURL: `${origin || 'https://slack.com'}/api/`,
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded' } });


  }

  get axios() {
    return this._axios;
  }

  get accessToken() {
    return this._token;
  }

  callMethod(
  method,
  body = {})
  {var _this = this;return _asyncToGenerator(function* () {
      try {
        body.token = body.token || _this._token; // eslint-disable-line no-param-reassign
        const response = yield _this._axios.post(
        method,
        _querystring2.default.stringify(body));const

        data = response.data,config = response.config,request = response.request;

        if (!data.ok) {
          throw new _axiosError2.default(`Slack API - ${data.error}`, {
            config,
            request,
            response });

        }

        return data;
      } catch (err) {
        throw new _axiosError2.default(err.message, err);
      }})();
  }

  /**
     * Gets information about a public channel.
     *
     * https://api.slack.com/methods/channels.info
     */
  getChannelInfo(
  channelId,
  options = {})
  {
    return this.callMethod('channels.info', _extends({
      channel: channelId },
    options)).
    then(data => data.channel);
  }

  /**
     * Lists all public channels in a Slack team.
     *
     * https://api.slack.com/methods/channels.list
     * FIXME: [breaking] support cursor, exclude_archived, exclude_members, limit
     */
  getChannelList() {
    return this.callMethod('channels.list').then(data => data.channels);
  }

  /**
     * Retrieve information about a conversation.
     *
     * https://api.slack.com/methods/conversations.info
     */
  getConversationInfo(
  channelId,
  options = {})
  {
    return this.callMethod('conversations.info', _extends({
      channel: channelId },
    options)).
    then(data => data.channel);
  }

  /**
     * Retrieve members of a conversation.
     *
     * https://api.slack.com/methods/conversations.members
     */
  getConversationMembers(
  channelId,
  options = {})



  {
    return this.callMethod('conversations.members', _extends({
      channel: channelId },
    options)).
    then(data => ({
      members: data.members,
      next: data.response_metadata && data.response_metadata.next_cursor }));

  }

  getAllConversationMembers(channelId) {var _this2 = this;return _asyncToGenerator(function* () {
      let allMembers = [];
      let continuationCursor;

      do {var _ref =




        yield _this2.getConversationMembers(channelId, {
          cursor: continuationCursor });const members = _ref.members,next = _ref.next;

        allMembers = allMembers.concat(members);
        continuationCursor = next;
      } while (continuationCursor);

      return allMembers;})();
  }

  /**
     * Lists all channels in a Slack team.
     *
     * https://api.slack.com/methods/conversations.list
     */
  getConversationList(
  options = {})



  {
    return this.callMethod('conversations.list', options).then(data => ({
      channels: data.channels,
      next: data.response_metadata && data.response_metadata.next_cursor }));

  }

  getAllConversationList(
  options = {})
  {var _this3 = this;return _asyncToGenerator(function* () {
      let allChannels = [];
      let continuationCursor;

      do {var _ref2 =




        yield _this3.getConversationList(_extends({},
        options, {
          cursor: continuationCursor }));const channels = _ref2.channels,next = _ref2.next;

        allChannels = allChannels.concat(channels);
        continuationCursor = next;
      } while (continuationCursor);

      return allChannels;})();
  }

  /**
     * Sends a message to a channel.
     *
     * https://api.slack.com/methods/chat.postMessage
     */
  postMessage(
  channel,
  message,


  options = {})
  {
    if (options.attachments && typeof options.attachments !== 'string') {
      // A JSON-based array of structured attachments, presented as a URL-encoded string.
      // eslint-disable-next-line no-param-reassign
      options.attachments = JSON.stringify(options.attachments);
    } else if (
    typeof message === 'object' &&
    message.attachments &&
    typeof message.attachments !== 'string')
    {
      // eslint-disable-next-line no-param-reassign
      message.attachments = JSON.stringify(message.attachments);
    }

    if (typeof message === 'string') {
      return this.callMethod('chat.postMessage', _extends({
        channel,
        text: message },
      options));

    }
    return this.callMethod('chat.postMessage', _extends({
      channel },
    message,
    options));

  }

  /**
     * Sends an ephemeral message to a user in a channel.
     *
     * https://api.slack.com/methods/chat.postMessage
     */
  postEphemeral(
  channel,
  user,
  message,


  options = {})
  {
    if (options.attachments && typeof options.attachments !== 'string') {
      // A JSON-based array of structured attachments, presented as a URL-encoded string.
      // eslint-disable-next-line no-param-reassign
      options.attachments = JSON.stringify(options.attachments);
    } else if (
    typeof message === 'object' &&
    message.attachments &&
    typeof message.attachments !== 'string')
    {
      // eslint-disable-next-line no-param-reassign
      message.attachments = JSON.stringify(message.attachments);
    }

    if (typeof message === 'string') {
      return this.callMethod('chat.postEphemeral', _extends({
        channel,
        user,
        text: message },
      options));

    }
    return this.callMethod('chat.postEphemeral', _extends({
      channel,
      user },
    message,
    options));

  }

  /**
     * Gets information about a user.
     *
     * https://api.slack.com/methods/users.info
     */
  getUserInfo(
  userId,
  options = {})
  {
    return this.callMethod('users.info', _extends({ user: userId }, options)).then(
    data => data.user);

  }

  /**
     * Lists all users in a Slack team.
     *
     * https://api.slack.com/methods/users.list
     * FIXME: [breaking] support include_locale, limit, presence
     */
  getUserList(
  cursor)
  {
    return this.callMethod('users.list', { cursor }).then(data => ({
      members: data.members,
      next: data.response_metadata && data.response_metadata.next_cursor }));

  }

  getAllUserList() {var _this4 = this;return _asyncToGenerator(function* () {
      let allUsers = [];
      let continuationCursor;

      do {var _ref3 =




        yield _this4.getUserList(continuationCursor);const users = _ref3.members,next = _ref3.next;
        allUsers = allUsers.concat(users);
        continuationCursor = next;
      } while (continuationCursor);

      return allUsers;})();
  }}exports.default = SlackOAuthClient;